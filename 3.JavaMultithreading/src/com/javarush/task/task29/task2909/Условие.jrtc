<<<<<<< HEAD
taskKey="com.javarush.task.task29.task2909.big03"

Рефакторинг (3)

3.1.	Спуск поля. Спусти поле course в соответствующий класс. Сделай его приватным.
3.2.	Спуск метода. Спусти геттер для поля course в соответствующий класс.
3.3.	Извлечение интерфейса.
3.3.1.	Создай интерфейс Alive (живой) в пакете human.
3.3.2.	Интерфейс должен содержать метод жить live().
3.3.3.	Добавь интерфейс нужному классу.
3.4.	Свертывание иерархии. Избавься от класса Professor.


Требования:
1.	Необходимо спустить поле course в нужный класс и сделать его приватным.
2.	Необходимо спустить геттер для поля course в нужный класс.
3.	Интерфейс Alive должен существовать в пакете human.
4.	Интерфейс Alive должен содержать объявление метода жить live().
5.	Класс Human должен поддерживать интерфейс Alive.
6.	Класс Professor нужно удалить.


Рефакторинг (2)

2.1.	Извлечение подкласса.
2.1.1.	Добавь класс Soldier в пакет human.
2.1.2.	Избавься от поля isSoldier.
2.1.3.	Перенеси в Soldier необходимые методы из Human.
2.1.4.	Обнови сигнатуру конструктора Human.
2.2.	Подъем тела конструктора.
2.2.1.	Перенеси инициализацию полей name и age в подходящее место, добавь необходимые параметры в конструктор Human.
2.2.2.	Добавь конструктор в класс Soldier.



Рефакторинг (1)

Пришло время немного порефакторить. Википедия говорит: "Рефакторинг (англ. refactoring)
или реорганизация кода - процесс изменения внутренней структуры программы, не
затрагивающий её внешнего поведения и имеющий целью облегчить понимание её работы. В
основе рефакторинга лежит последовательность небольших эквивалентных (то есть
сохраняющих поведение) преобразований. Поскольку каждое преобразование маленькое,
программисту легче проследить за его правильностью, и в то же время вся
последовательность может привести к существенной перестройке программы и улучшению её
согласованности и четкости." Такими маленькими преобразованиями мы и будем заниматься.
После каждого изменения следи за сохранностью работоспособности кода.
Многие методы рефакторинга не однократно применены и проверены сообществом
программистов. Получили свои названия. Каждое задание будет сопровождено названием
рефакторинга. Ты всегда можешь прочитать более подробно о нем в книге Мартина Фаулера
"Рефакторинг: Улучшение существующего кода".
Начнем. Внимательно ознакомься с кодом пакета human (человек).

Задания:
1.1.	Подъем поля. Подними поле children в базовый класс.
1.2.	Подъем метода. Подними сеттер и геттер для children в базовый класс.
1.3.	Инкапсуляция коллекции.
1.3.1.	Метод getChildren должен возвращать не модифицируемое представление списка children.
1.3.2.	Убери сеттер для children.
1.3.3.	Добавь методы addChild (Human) и removeChild (Human). Реализуй их логику.
=======
taskKey="com.javarush.task.task29.task2909.big15"

Рефакторинг (15)

Отлично. Ты освоил основные методы рефакторинга: Подъем поля, Подъем метода,
Инкапсуляция коллекции, Извлечение подкласса, Подъем тела конструктора, Спуск
метода, Спуск поля, Извлечение интерфейса, Свертывание иерархии, Замена наследования
делегированием, Извлечение суперкласса, Замена простого поля объектом, Создание
шаблонного метода, Замена делегирования наследованием, Переименование метода,
Замена параметра набором специализированных методов, Добавление параметра,
Удаление параметра, Разделение запроса и модификатора, Параметризация метода,
Передача всего объекта, Замена параметра вызовом метода, Замена параметров
объектом, Удаление сеттера, Сокрытие метода, Замена исключения проверкой условия,
Удаление управляющего флага, Самоинкапсуляция поля, Замена поля-массива объектом,
Инкапсуляция поля, Замена кодирования типа классом, Замена конструктора фабричным
методом, Замена кода ошибки исключением, Разбиение условного оператора,
Объединение условных операторов, Объединение дублирующихся фрагментов в условных
операторах, Замена магического числа символьной константой, Замена условного
оператора полиморфизмом, Извлечение метода, Встраивание метода, Перемещение
метода, Расщепление переменной, Удаление присваиваний параметрам, Перемещение
поля, Извлечение класса, Встраивание класса и Сокрытие делегирования.

Конечно есть еще и другие, обязательно ознакомься и с ними. Очень важно не только
уметь применять методы рефакторинга, но и видеть места, где их нужно применить. По
мере возрастания опыта, такие места будет все проще и проще находить. Мартин Фаулер в
своей книге "Рефакторинг: Улучшение существующего кода" называет такие места "код с
душком". Обязательно прочитай про основные варианты "кода с душком". Желаю, чтобы
твой код пах хорошо!


Требования:
1.	Тест всегда проходит.


Рефакторинг (14)

14.1.	Перемещение поля. Замени поля isManAnya и isManRoma полем man в нужном классе.
Добавь сеттер и геттер для нового поля (при выборе имен методов учти тип поля).
14.2.	Извлечение класса.
14.2.1.	Добавь класс Address в пакет user.
14.2.2.	Перенеси поля country, city и house в новый класс.
14.2.3.	Добавь сеттеры и геттеры для них.
14.2.4.	Перепиши класс User, используя поле класса Address address.
14.3.	Встраивание класса. Класс House почти ничего не делает, избавься от него.
14.4.	Сокрытие делегирования.
14.4.1.	Добавь в класс User метод getBoss().
14.4.2.	Перепиши реализацию метода getBossName(User user) класса UserHelper.



Рефакторинг (13)

Разберись с кодом пакета user (пользователь).
13.1.	Извлечение метода. Добавь метод printInfo(), который будет выводить имя и фамилию
в консоль в формате

Имя: Вася
Фамилия: Пупкин

Замени повторяющийся код метода printUsers() его вызовом.
13.2.	Встраивание метода. Избавься от метода ageLessThan16().
13.3.	Перемещение метода. Перемести методы printInfo() и printAdditionalInfo() в класс User.
13.4.	Расщепление переменной. Переменная age в методе calculateAverageAge()
используется для разных промежуточных значений. Перепиши метод без использования этой переменной.
13.5.	Удаление присваиваний параметрам. Перепиши метод calculateRate(), чтобы он не
пытался менять входные параметры, а просто возвращал рассчитанное значение.



Рефакторинг (12)

12.1.	Объединение условных операторов.
12.1.1.	Добавь внутренний метод, сообщающий, могут ли быть перевезены пассажиры
boolean canPassengersBeTransferred() в класс Car. Метод должен возвращать true, если
водитель доступен isDriverAvailable и есть топливо fuel.
12.1.2.	Перепиши метод getNumberOfPassengersCanBeTransferred(), объединив условные
операторы (используй метод canPassengersBeTransferred()).
12.2.	Объединение дублирующихся фрагментов в условных операторах. Перепиши метод
startMoving(), чтобы в нем не было повторяющихся вызовов функций.
12.3.	Замена магического числа символьной константой. Замени магические числа в методе
getMaxSpeed() на константные переменные метода: MAX_TRUCK_SPEED,
MAX_SEDAN_SPEED и MAX_CABRIOLET_SPEED.
12.4.	Замена условного оператора полиморфизмом.
12.4.1.	Переопредели метод getMaxSpeed() в подклассах, избавившись от условного оператора.
12.4.2.	Метод getMaxSpeed() в классе Car сделай абстрактным.



Рефакторинг (11)

11.1.	Замена кода ошибки исключением. Перепиши метод заправиться fill(double
numberOfLiters), чтобы он в случае ошибки кидал исключение Exception.
11.2.	Разбиение условного оператора.
11.2.1.	Добавь и реализуй метод в классе Car, определяющий относится ли переданная дата к
лету: boolean isSummer(Date date , Date summerStart, Date summerEnd).
11.2.2.	Добавь и реализуй метод, рассчитывающий расход топлива зимой: double
getWinterConsumption(int length).
11.2.3.	Добавь и реализуй метод, рассчитывающий расход топлива летом: double
getSummerConsumption(int length).
11.2.4.	Перепиши метод getTripConsumption(), используя новые методы.



Рефакторинг (10)

Разберись с кодом в пакете car (машина).
10.1.	Замена конструктора фабричным методом.
10.1.1.	Объяви классы Truck (грузовик), Sedan (седан) и Cabriolet (кабриолет), унаследованные от Car.
10.1.2.	Добавь в них конструкторы, принимающие int numberOfPassengers.
10.1.3.	Добавь фабричный статический метод Car create(int type, int numberOfPassengers) в класс Car и реализуй его.
10.1.4.	Измени область видимости конструктора класса Car.
>>>>>>> 868a4eae797161c67a4d9d5eb80d92a4e250d3d0



